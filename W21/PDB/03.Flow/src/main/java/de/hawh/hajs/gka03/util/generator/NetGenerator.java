package de.hawh.hajs.gka03.util.generator;

import org.graphstream.graph.Graph;
import org.graphstream.graph.Node;
import org.graphstream.graph.implementations.SingleGraph;

import java.util.Optional;
import java.util.concurrent.ThreadLocalRandom;

/**
 * This class generates random nets.
 *
 * @author Hani Alshikh
 * @author Jannik Stuckst√§tte
 */
public class NetGenerator {

    private static String capacityAttributeName;
    private static Graph generatedGraph;
    private static double capacityLowerBound;
    private static double capacityUpperBound;

    /**
     * This method is used to generate a random net. In some special cases the number of edges
     * will only be approximately the desired number. The nets generated by this methods will always
     * have a "real" source and sink meaning the source will only have leaving edges and the sink
     * will only have entering edges. The ids of source and sink will be "q" and "s".
     *
     * @param nodeCount             Number of nodes in the generated net. Needs to be at least 2.
     * @param edgeCount             Number of edghes in the generated net. Result will slightly
     *                              differ from given number in some cases.
     * @param capacityLowerBound    Lower bound to be used for randomly assigned capacities.
     * @param capacityUpperBound    Upper bound to be used for randomly assigned capacities.
     * @param capacityAttributeName Attribute name used to set capacity values.
     * @return The generated graph.
     */
    public static Graph generate(int nodeCount, int edgeCount, double capacityLowerBound,
        double capacityUpperBound, String capacityAttributeName, String id) {
        if (nodeCount < 2 || edgeCount < 1) {
            throw new IllegalArgumentException("nodeCount and edgeCount needs to be positive");
        }

        if (edgeCount > ((nodeCount - 1) * nodeCount) / 2) {
            throw new IllegalArgumentException(
                "A net can only contain ((nodeCount - 1) * nodeCount) / 2 edges");
        }

        if (edgeCount < nodeCount - 1) {
            throw new IllegalArgumentException(
                "A net needs to contain at least nodeCount - 1 number of edges");
        }

        if (capacityLowerBound < 0 || capacityUpperBound < 0) {
            throw new IllegalArgumentException(
                "Capacity cannot be negative. Bounds must be positive.");
        }

        if (capacityUpperBound < capacityLowerBound) {
            throw new IllegalArgumentException(
                "Upper bounds must be equal or greater than lower bounds");
        }

        NetGenerator.capacityLowerBound = capacityLowerBound;
        NetGenerator.capacityUpperBound = capacityUpperBound;
        NetGenerator.capacityAttributeName = capacityAttributeName;
        generatedGraph = new SingleGraph(id);

        // generate all nodes except source and sink
        for (int i = 0; i < nodeCount - 2; i++) {
            generatedGraph.addNode(i + "");
        }
        // connect all generated nodes to a random other one with a random direction
        for (int i = 0; i < nodeCount - 3; i++) {
            Node currentNode = generatedGraph.nodes()
                .filter(node -> node.getDegree() == 0)
                .findAny().orElseThrow();
            Node oppositeNode = generatedGraph.nodes()
                .filter(node -> !node.getId().equals(currentNode.getId()))
                .filter(node -> !currentNode.hasEdgeBetween(node))
                .findAny().orElseThrow();

            addEdgeRandomCapacityRandomDirection(oppositeNode,
                currentNode);
        }

        int numberOfEdgesFromSource = 1;
        int numberOfEdgesToSink = 1;
        int remainingEdges = edgeCount - (nodeCount - 3);

        if (remainingEdges > 2) {
            numberOfEdgesFromSource = Math.min(nodeCount - 1, ThreadLocalRandom.current()
                .nextInt(1, remainingEdges));
            remainingEdges -= numberOfEdgesFromSource;
            numberOfEdgesToSink = Math.min(nodeCount - 2, ThreadLocalRandom.current()
                .nextInt(1, remainingEdges + 1));
            remainingEdges -= numberOfEdgesToSink;

            for (int i = 0; i < remainingEdges; i++) {
                Optional<Node> uOpt = generatedGraph.nodes()
                    .filter(node -> node.getDegree() < (nodeCount - 3))
                    .findAny();
                if (uOpt.isEmpty()) {
                    // If we get in here we cant add all remaining edges to the center
                    // so we just dismiss them
                    break;
                }
                Node u = uOpt.get();
                Node v = generatedGraph.nodes()
                    .filter(node -> !node.getId().equals(u.getId()))
                    .filter(node -> !node.hasEdgeBetween(u))
                    .findAny().orElseThrow();

                addEdgeRandomCapacityRandomDirection(v, u);
            }
        }
        Node sourceNode = generatedGraph.addNode("q");
        Node sinkNode = generatedGraph.addNode("s");

        for (int i = 0; i < numberOfEdgesFromSource; i++) {
            Node nodeTo = generatedGraph.nodes()
                .filter(node -> !node.getId().equals(sourceNode.getId()))
                .filter(node -> !node.hasEdgeFrom(sourceNode)).findAny().orElseThrow();
            addEdgeRandomCapacity(sourceNode, nodeTo);
        }

        for (int i = 0; i < numberOfEdgesToSink && nodeCount > 2; i++) {
            Node nodeFrom = generatedGraph.nodes()
                .filter(node -> !node.getId().equals(sinkNode.getId()))
                .filter(node -> !node.hasEdgeToward(sinkNode)).findAny().orElseThrow();
            addEdgeRandomCapacity(nodeFrom, sinkNode);
        }
        return generatedGraph;
    }

    public static Graph generate(int nodeCount, int edgeCount, double capacityLowerBound,
                                 double capacityUpperBound, String capacityAttributeName) {
        return generate(nodeCount, edgeCount, capacityLowerBound, capacityUpperBound, capacityAttributeName,
                ThreadLocalRandom.current().nextInt() + "");
    }

    /**
     * Used to add a directed edge from "from" to "to" and assign a random capacity between the
     * given bounds.
     *
     * @param from Node to add the leaving edge to.
     * @param to Node to add the entering edge to.
     */
    private static void addEdgeRandomCapacity(Node from, Node to) {
        String edgeId = from.getId() + "-" + to.getId();
        NetGenerator.generatedGraph
            .addEdge(edgeId, from.getId(), to.getId(),
                true);
        double capacity = capacityLowerBound < capacityUpperBound ? ThreadLocalRandom.current()
            .nextDouble(capacityLowerBound, capacityUpperBound) : capacityLowerBound;
        NetGenerator.generatedGraph.getEdge(edgeId).setAttribute(capacityAttributeName, capacity
        );
    }

    /**
     *
     * @param from
     * @param to
     */
    private static void addEdgeRandomCapacityRandomDirection(Node from, Node to) {
        if (from.hasEdgeBetween(to)) {
            throw new IllegalStateException();
        } else {
            if (ThreadLocalRandom.current().nextBoolean()) {
                addEdgeRandomCapacity(from, to);
            } else {
                addEdgeRandomCapacity(to, from);
            }
        }
    }
}
